/**
 * MIRA GENERATOR ENGINE (Enterprise ETL)
 * --------------------------------------
 * Transforma JSONs procesados en artefactos de despliegue (SQL & Seeders).
 * No requiere dependencias externas (solo mÃ³dulos nativos de Node.js).
 * * Usage: node generators/generate_artifacts.js
 */

const fs = require('fs');
const path = require('path');

// CONFIGURACIÃ“N DE RUTAS
const PATHS = {
    input: path.join(__dirname, '../01_processed_json'),
    output_sql: path.join(__dirname, '../02_final_artifacts/postgres'),
    output_seeder: path.join(__dirname, '../02_final_artifacts/seeders')
};

// ASEGURAR DIRECTORIOS
Object.values(PATHS).forEach(dir => {
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
});

// UTILIDADES
const escapeSql = (str) => {
    if (!str) return '';
    // Escapa comillas simples para Postgres (Standard SQL)
    return str.replace(/'/g, "''");
};

const shuffleArray = (array) => {
    // Algoritmo Fisher-Yates para aleatorizaciÃ³n perfecta
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
};

/**
 * Convierte el objeto de opciones estructuradas del Agente en un Array Aleatorio
 * preservando la metadata de cuÃ¡l es la correcta.
 */
const processOptions = (structuredOptions) => {
    if (!structuredOptions) return null;

    // Mapear claves internas a objetos finales
    const mapping = [
        { key: 'integrity_correct', is_correct: true, archetype: 'Integrity' },
        { key: 'pragmatic_distractor', is_correct: false, archetype: 'Pragmatic' },
        { key: 'evasive_distractor', is_correct: false, archetype: 'Evasive' },
        { key: 'rationalized_distractor', is_correct: false, archetype: 'Rationalized' }
    ];

    const finalOptions = [];

    mapping.forEach(map => {
        if (structuredOptions[map.key]) {
            finalOptions.push({
                text: structuredOptions[map.key],
                is_correct: map.is_correct,
                meta_type: map.archetype // Guardamos el arquetipo para anÃ¡lisis de datos futuro
            });
        }
    });

    return shuffleArray(finalOptions);
};

// --- MOTOR PRINCIPAL ---

const generate = () => {
    console.log('ðŸš€ Iniciando GeneraciÃ³n de Artefactos MIRA...');

    const files = fs.readdirSync(PATHS.input).filter(f => f.endsWith('.json'));

    let masterSqlBuffer = `-- MIRA REFACTORED DATABASE MIGRATION\n-- Generated: ${new Date().toISOString()}\n\n`;
    let masterSeederData = [];

    files.forEach(file => {
        console.log(`ðŸ“„ Procesando archivo: ${file}`);
        const content = JSON.parse(fs.readFileSync(path.join(PATHS.input, file), 'utf8'));

        // Validar que sea un array
        if (!Array.isArray(content)) {
            console.warn(`âš ï¸ Advertencia: ${file} no es un array JSON vÃ¡lido. Saltando.`);
            return;
        }

        content.forEach(item => {
            // 1. Procesar Opciones (si existen)
            let optionsJson = null;
            let optionsSqlString = 'NULL';

            if (item.type === 'options' && item.options_structured) {
                const shuffled = processOptions(item.options_structured);
                optionsJson = shuffled;
                // Convertir a string JSON vÃ¡lido para columna JSONB de Postgres
                optionsSqlString = `'${JSON.stringify(shuffled).replace(/'/g, "''")}'`; // Doble escape para estar dentro de SQL string
            }

            // 2. Limpieza de Texto Principal
            const safeText = escapeSql(item.refactored_text || item.scenario_text);

            // 3. Generar SQL Line
            // Asumimos tabla 'questions' con estructura moderna
            const sqlLine = `INSERT INTO questions (legacy_id, module_score, type, content, options_metadata, created_at) VALUES (${item.source_id}, '${item.module_score}', '${item.type}', '${safeText}', ${optionsSqlString}, NOW()) ON CONFLICT (legacy_id) DO NOTHING;`;

            masterSqlBuffer += sqlLine + '\n';

            // 4. Agregar a Memoria para Seeder
            masterSeederData.push({
                legacy_id: item.source_id,
                module: item.module_score,
                type: item.type,
                content: item.refactored_text || item.scenario_text,
                options: optionsJson
            });
        });
    });

    // --- ESCRITURA DE ARTEFACTOS ---

    // 1. Escribir SQL
    const sqlPath = path.join(PATHS.output_sql, 'migration_master.sql');
    fs.writeFileSync(sqlPath, masterSqlBuffer);
    console.log(`âœ… SQL Master generado en: ${sqlPath}`);

    // 2. Escribir Seeder (Formato Universal .ts)
    const seederContent = `
/**
 * MIRA SEEDER FILE
 * Auto-generated by Enterprise ETL
 */

export const questionSeed = ${JSON.stringify(masterSeederData, null, 2)};
    `;

    const seederPath = path.join(PATHS.output_seeder, 'master_seeder.ts');
    fs.writeFileSync(seederPath, seederContent);
    console.log(`âœ… Seeder Master generado en: ${seederPath}`);

    console.log('âœ¨ Proceso Terminado Exitosamente.');
};

// EJECUTAR
try {
    generate();
} catch (error) {
    console.error('ðŸ”¥ Error CrÃ­tico en el Generador:', error);
    process.exit(1);
}